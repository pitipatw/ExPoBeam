include("main.jl")


#Define boundary for sampling x1 to x9
s_fc′ = 28.:2.0:56.
s_aps = 100.:100.:1000.
s_L = 200.:50.:750.
s_t = [20.] #10.:5.:30.
s_Lc = 10.:5.:30.
s_fpe = 100.:50.:1000.
s_e = 0.5:0.1:1.2
s_l = 4000.
s_baydepth = 1000.
s_fR1 = [4.0]
s_fR3 = [3.5]


nsam_pts = size(s_fc′)[1]*size(s_aps)[1]*size(s_L)[1]*size(s_t)[1]*size(s_Lc)[1]*size(s_fpe)[1]*size(s_e)[1]*size(s_fR1)[1]*size(s_fR3)[1]
nsam_pts*1/60/60/24
#store val vector 

#create combinations of these parameters in a matrix
val = zeros(nsam_pts, 11)
res = zeros(nsam_pts, 3)
checkres = zeros(nsam_pts, 1)
for x1 in s_fc′
    println("fc′: ", x1)
    for x2 in s_aps
        for x3 in s_L
            for x4 in s_t
                for x5 in s_Lc
                    for x6 in s_fpe
                        for x7 in s_e
                            for x8 in s_fR1
                                for x9 in s_fR3
                                    val[1,1] = x1
                                    val[1,2] = x2
                                    val[1,3] = x3
                                    val[1,4] = x4
                                    val[1,5] = x5
                                    val[1,6] = x6
                                    val[1,7] = x7
                                    val[1,8] = x8
                                    val[1,9] = x9

                                    out = sampleme(x1, x2, x3, x4, x5, x6, x7,l[1], baydepth[1], x8, x9)
                                    res = out[1:3]
                                    checkres = out[4]

                                end
                            end
                        end
                    end
                end
            end
        end
    end
end


pu, mu, vu, ~, limitchecks = 