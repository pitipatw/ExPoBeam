using Makie, GLMakie

include("pixelgeo.jl")

nodes = fullpixel(150,30,20)

f4 = Figure(resolution = (800, 800))
ax4 = Axis(f4[1, 1], xlabel = "x", ylabel = "y", aspect = DataAspect())#, aspect = DataAspect(), xgrid = false, ygrid = false)
scatter!(ax4, nodes[:,1],nodes[:,2], color = :red )
f4
dx = 0.1
dy = 0.1
points = fillpoints(nodes, dx, dy)

check = pointsinpixel(nodes, points)

f1 = Figure(resolution = (800, 800))
ax1 = Axis(f1[1, 1], xlabel = "x", ylabel = "y", aspect = DataAspect())#, aspect = DataAspect(), xgrid = false, ygrid = false)
p1 = scatter!(ax1, points[check[:,1],1],points[check[:,1],2], color = :green )
f1




p_inpoly = points[check,:]
top = maximum(p_inpoly[:,2])
area =dx*dy*size(p_inpoly)[1]

chk = Vector{Bool}(undef, size(p_inpoly)[1])
c_pos = top - 80.0
@time for i =1:size(p_inpoly)[1]
    x = p_inpoly[i,1]
    y = p_inpoly[i,2]
    if y>c_pos
        chk[i] = true
    else
        chk[i] = false
    end
end

@time @Threads.threads for i =1:size(p_inpoly)[1]
    x = p_inpoly[i,1]
    y = p_inpoly[i,2]
    if y>c_pos
        chk[i] = true
    else
        chk[i] = false
    end
end

com_pts = p_inpoly[chk,:]

f3 = Figure(resolution = (800,600))
ax3 = Axis(f3[1,1,] , xlabel = "x", ylabel = "y", aspect = DataAspect())
p3 = scatter!(ax3, p_inpoly[:,1], p_inpoly[:,2], color = :red, markersize = 2)
f3


p4 = scatter!(ax3, com_pts[:,1], com_pts[:,2], color = :green, markersize = 1)
f3

com_pts 

#find moment of inertia of the point related to an axis y = c

c = 0
pts_inertia = p_inpoly
# 
pts_inertia = com_pts
area = size(pts_inertia)[1]*dx*dy
global cgx = 0.0
global cgy = 0.0
global inertia = 0.0
c = 0.0
dxdy = dx*dy
# @time @Threads.threads 
for i =1:size(pts_inertia)[1]
    x = pts_inertia[i,1]
    y = pts_inertia[i,2]
    r = (y-c)
    global inertia += r^2*dxdy
    global cgx += x*dxdy
    global cgy += y*dxdy
end
cg = (cgx/area, cgy/area)
p4 = scatter!(ax3, cg[1], cg[2], color = :blue, markersize = 10)
f3


Area = size(p_inpoly)[1]*dxdy
inertia
answer = 1.1867e8
println("Calculated: ", inertia)
# answer = 1/12*10^4

println("Answer ", answer)
println("error: ", (answer-inertia)/answer*100, " %")
# println("result: ", 1/12*10^4)


# ####################################


#given area, get depths
target_a = 1500.0
tol = 0.01
for depth_ratio = 0:0.01:1
    #more efficient by adding more points?
    #if the points are sorted, we could continue?, but with each depth.

    chk = Vector{Bool}(undef, size(p_inpoly)[1])
    @show c_pos = 100-depth_ratio*200.0
    for i =1:size(p_inpoly)[1]
        #could stop right away when the points violate the depth (move in sorted list)
        x = p_inpoly[i,1]
        y = p_inpoly[i,2]
        if y>c_pos
            chk[i] = true
        else
            chk[i] = false
        end
    end
    com_pts = p_inpoly[chk,:]
    @show area =dx*dy*size(com_pts)[1]
    @show diff = abs(area-target_a)/target_a
    if diff < tol 
        println("the depth is at y = ", depth_ratio*200.0)
        break
    end
end

